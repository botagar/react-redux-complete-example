<html>
	<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
    
    <link rel="stylesheet" href="css/presentation.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section> <!-- Slide 1: cover slide -->
          <h1>Implementing React + Redux from Scratch</h1>
          <h2>A beginners journey</h2>
          <div class="slide-1 meta-info">
            <p class="small">Node version 6.10.1</p>
            <p class="small">React version 15.6.1</p>
            <p class="small">Redux version 3.7.2</p>
            <p class="small">Last updated 2017-08-17</p>
          </div>
        </section>
				<section> <!-- Slide 2: into to project -->
          <p>We have a brilliant idea! We NEED to create an app which fetches the public repositories from a users GitHub...</p>
          <p class="fragment">And we've also heard about this newfangled tech called React, and that it meshes well with Redux. Cool~!</p>
          <p class="fragment">I know NOTHING about either of those frameworks, but how hard could it be?...</p>
          <p class="fragment">Oh... and I don't like code being scaffolded out for me...</p>

          <p class="fragment sarcastic-note-right">AHHHhahhahahaaahahaahaaaaaaa...... ðŸ˜ˆðŸ™ˆ</p>
        </section>
        <section> <!-- Slide 3: install basic packages -->
          <section data-markdown>
            <script type="text/template">
              ## Setup
              I use [Yarn](https://yarnpkg.com/) for package management
              ```
              npm install -g yarn
              ```
              <br />
              <br />
              I also recommend using [nvm](https://github.com/creationix/nvm) for node version management 
              and [npm-check](https://www.npmjs.com/package/npm-check) for keeping track of and updating package versions
              ```
              npm install -g npm-check
              curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Install the basic core React libs
              ```
              yarn add react react-dom react-router-dom
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Install our build tools
              ```
              yarn add babel-core babel-loader babel-preset-es2015 \
                babel-preset-react webpack
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Create a new node project
              ```
              npm init
              ```
              <br />
              And proceed onwards!! ==>
            </script>
          </section>
        </section>
        <section> <!-- Slide 4: setup main and index -->
          <section>
            <h1>Hello World</h1>
            <p>Let's create our index.html and main.js files in the src directory</p>
            <img src="resources/slide-3.1-file-structure.png" />
          </section>
        </section>
        <section> <!-- Slide 5: index.html -->
          <section data-markdown>
            <script type="text/template">
              ## index.html
              ```
                <html>
                  <head>
                      <title>Example App</title>
                  </head>
                  <body>
                      <div id = "app"></div>
                      <script src = "app.bundle.js">__SCRIPT_END__
                  </body>
                </html>
              ```
              <div class="hidden">`</div>
              <br />
              Let's quickly break down what's going on here
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              <head>
                  <title>Example App</title>
              </head>
              ```
              <br />
              Nothing special needs to go here.  
              You can add your usual meta tags and other "head" related functionality.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              <body>
                  <div id = "app"></div>
                  <script src = "app.bundle.js">__SCRIPT_END__
              </body>
              ```
              <div class="hidden">`</div>
              <br />
              Our React App will be rendered in the div with id "app"  
              And of course, we need to import our js (which we will be building)
            </script>
          </section>
        </section>
        <section> <!-- Slide 6: webpack.config.js -->
          <section data-markdown>
            <script type="text/template">
              ## Now let's setup our build system!
              (Skip this section if you are comfortable with basic webpack setup)  
              We'll be using Webpack and Babel to transpile and package our app  
                
              Create a file in the src directory called "webpack.config.js" then lets start with the following:
              ```
              var webpack = require('webpack')
              var path = require('path')

              var SRC = path.resolve(__dirname, 'src')
              var DIST = path.resolve(__dirname, 'dist')

              var config = {
                
              }

              module.exports = config
              ```
              Note: "__dirname" is a nodejs variable returning the directory of the currently executing script
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Define an entry point and build output for our app
              ```
              var config = {
                entry: [
                  './src/main.js'
                ],
                output: {
                  path: DIST,
                  filename: 'app.bundle.js'
                }
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              At this stage, we can call webpack to (try) build stuff!  
              Add the build command to your config.json file
              ```
              "scripts": {
                "build": "webpack",
                "test": "echo \"Error: no test specified\" && exit 1"
              }
              ```
              Now we can run the following command in the terminal
              ```
              yarn build
              ```
              This should create a new directory called "dist", and there should be a file "app.bundle.js"
            </script>
          </section>
          <section>
            <h2>Cool! But it doesn't really do anything...</h2>
            <p class="fragment">But that's ok. ONWARDS! ==></p>
          </section>
        </section>
        <section> <!-- Slide 7: main.js -->
          <section data-markdown>
            <script type="text/template">
              Let's start creating content.  
              In main.js, copy+paste the following
              ```
              import React from 'react'
              import ReactDOM from 'react-dom'

              const appContainer = document.getElementById('app')

              ReactDOM.render(
                <h1>Hello World</h1>,
                appContainer
              )
              ```
              <br />
              There is an issue now. If you try build this, you will get an error.  
              This is because Webpack does not know how to handle this content.  
              We need a [Transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler)! Good thing we installed [Babel](https://babeljs.io) ðŸ˜‰
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              The ReactDOM.render() method is where the main magic happens.  
              As defined in the [ReactDOM docs](https://facebook.github.io/react/docs/react-dom.html), render() takes the following arguments
              ```
              ReactDOM.render(
                element,
                container,
                [callback]
              )
              ```
              Where "element" is the what we want do display (in our case, "<h1>hello world</h1>") and  
              "container" is the div with the id "app".  
              <br />
              The callback is optional, and we will not be making use of it this time.
            </script>
          </section>
        </section>
        <section> <!-- Slide 8: babel setup -->
          <section data-markdown>
            <script type="text/template">
              ## Babel setup
              (skip this section if you are comfortable with babel setup)  
              <br />
              Let's add a new file called ".babelrc" and populate it with the following
              ```
              {
                "presets": [
                  "react",
                  "es2015"
                ]
              }
              ```
              This congifures babel to support es2015 and react .jsx format.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Note
              The .babelrc file is an extraction of the same config which can go into the package.json file.   
               <br />
              ```
              {
                "name": "myapp",
                "version": "1.0.0",
                "description": "",
                "main": "index.js",
                "scripts": {
                  "build": "webpack"
                },
                "author": "",
                "license": "ISC",
                "dependencies": {
                  ...
                },
                "babel": {
                  "presets": [
                    "react",
                    "es2015"
                  ]
                }
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              At this point, we can run  
              ```
              yarn build
              ```
              and we should have a successful build.  
              <br />
              To do a quick check, we can copy our index.html file into our dist directory then open it in a browser.  
              We should see "Hello World".
            </script>
          </section>
        </section>
        <section> <!-- Slide 9: menubar setup -->
          <section data-markdown>
            <script type="text/template">
              # Building a navigation bar
              Hello world is great and all, but we want to turn this into a site that actually does something
              We'll start by adding a really quick navigation bar.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Setting up the files
              For our navigation bar, we want to create a directory under src called common (We will be following a DDD approach to file structure).  
              Then we'll add a file called "navbar.component.jsx"  
              <img src="resources/slide-9.1-file-structure.png" />
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Let's start by defining a stateless function which will return our markup in "navbar.component.jsx"
              ```
              import React from 'react'
              import { NavLink } from 'react-router-dom'

              const NavBar = () =>
                <div></div>

              export default NavBar
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Inside those div's, we should setup our list of links as follows
              ```
              <div id="nav-bar">
                <ul className='nav-links'>
                    <li key='home'>
                        <NavLink to={'/'} activeClassName='active'>Home</NavLink>
                    </li>
                    <li key='github'>
                        <NavLink to={'/github'} activeClassName='active'>Github</NavLink>
                    </li>
                </ul>
              </div>
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Our file now looks like
              ```
              import React from 'react'
              import { NavLink } from 'react-router-dom'

              const NavBar = () =>
                <div id="nav-bar">
                  <ul className='nav-links'>
                      <li key='home'>
                          <NavLink to={'/'} activeClassName='active'>Home</NavLink>
                      </li>
                      <li key='github'>
                          <NavLink to={'/github'} activeClassName='active'>Github</NavLink>
                      </li>
                  </ul>
                </div>

              export default NavBar
              ```
              Let's dive into what we've setup here
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              <NavLink to={'/'} activeClassName='active'>Home</NavLink>
              ```
              The main difference here from how a navigation header is normally constructed is the use  
              of the `<NavLink>` element rather than a standard `<a>`.  
              <br />
              The 'to' property is the relative link to the desired page. The above example links to the home page.  
              The 'activeClassName' property give the link element the class name when it is active. This can be used to style active or inactive links.  
              See the [docs](https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/api/NavLink.md) for more information on the NavLink element.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              The exported NavBar can be used in our *main.js* file to be rendered to the page.  
              <br />
              Before we can do that though, we need to setup routing. This too can be done within *main.js*.  
              Add the following import to *main.js*
              ```
              import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'
              ```
              Then within the `<Router>` element in the ReactDOM.render() method, setup our routing switch as follows
              ```
              ReactDOM.render(
                <Router>
                  <div>
                    <Switch>
                    </Switch>
                  </div>
                </Router>,
                appContainer
              )
              ```
              (Yes, *Hello World* has been retired)
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Within the `<Switch>` elements, we can define all our routes.  
              We don't really have any pages yet, but we need to setup as many routes as we have links, even if they are empty.  
              Add 2 routes like so
              ```
              <Switch>
                <Route path={'/'} component={null} exact />
                <Route path={'/github'} component={null} exact />
              </Switch>
              ```
              <br />
              We will leave the routes like this for now. Let's now include our NavBar.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Still in *main.js*, import our NavBar component
              ```
              import NavBar from './common/navbar.component.jsx'
              ```
              Then add our NavBar to the render() method just above the `<Switch>`
              ```
              <Router>
                <NavBar />
                <Switch>
                  <Route path={'/'} component={null} exact />
                  <Route path={'/github'} component={null} exact />
                </Switch>
              </Router>
              ```
              <br />
              However....
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Now we'll run into trouble here as the Router element can only have 1 child element.  
              We can fix this by wrapping our Navbar and Switch in a single div, leaving our render() method looking like
              ```
              ReactDOM.render(
                <Router>
                  <div>
                    <NavBar />
                    <Switch>
                      <Route path={'/'} component={null} exact />
                      <Route path={'/github'} component={null} exact />
                    </Switch>
                  </div>
                </Router>,
                appContainer
              )
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We can build now successfully, but there should be a better way to test our site.  
              <br />
              Queue our webpack dev server! ==>
            </script>
          </section>
        </section>
        <section> <!-- Slide 10: hot reloading -->
          <section data-markdown>
            <script type="text/template">
              # Dev server and Hot Reloading
              We're going to setup our hot reloading dev server so that we can develop and see our changes in real time!

              Oh the fascinating modern age we live in!!
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Installing packages
              ```
              yarn add webpack-dev-server react-hot-loader@3.0.0-beta.7 file-loader
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Configuration
              To begin our configuration, we'll need to revisit our *webpack.config.js* file.
              Add the following to loaders array
              ```
              {
                test: /\.jsx?$/,
                exclude: /node_modules/,
                loader: 'babel-loader'
              }
              ```
              This tells webpack to use babel to interpret jsx files, but to exclude our installed node modules.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We'll also add a config entry to our loaders array to copy our static files to our dist folder
              ```
              {
                test: /\.html$/,
                loader: 'file-loader?name=[name].[ext]'
              }
              ```
              For our file loader to actually work though, we'll need to include the files we want in one of our compiled files.  
              Let's open up our *main.js* then add the following at the end of our imports
              ```
              import './index.html'
              ```
              It's important to note that the webpack 2 file loader does not automatically copy all files that match the
              test regex, but only those that are **also** included somewhere in the project.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We then need to add our dev server config to the config object and define another entry point into our app (the hot reloader module)
              ```
              devServer: {
                inline: true, // Hot reloading
                port: 8081, // Port which the Dev Server will listen on
                contentBase: './src', // Where the entry to your app is
                open: true // Open site in new browser tab upon command execution
              }
              ```
              Insert into our entry array **AS THE FIRST ENTRY**
              ```
              'react-hot-loader/patch'
              ```
              This tells webpack to start a dependency graph at the hot loader module as well as one from our main.  
              More on this can be found [here](https://webpack.js.org/concepts/entry-points/)  
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Let's also include a plugin which will make debugging much nicer
              ```
              plugins: [
                new webpack.NamedModulesPlugin()
              ]
              ```
              (the plugins array goes in the config object)  
              The Named Modules Plugin prints the module name and path instead of an internal ID when printing from a module.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We still need to setup the hot module reloading in our *main.js* file.
              To do this, lets extract our ReactDOM.render() method into its own method, creatively named *render()*
              ```
              const render = () => {
                ReactDOM.render(
                  <Router>
                    <div>
                      <NavBar />
                      <Switch>
                        <Route path={'/'} component={null} exact />
                        <Route path={'/github'} component={null} exact />
                      </Switch>
                    </div>
                  </Router>,
                  appContainer
                )
              }
              render()
              ```
              We haven't changed any functionality at this point but we are now primed to setup hot reloading.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              (In *main.js*) Import the hot reloading app container
              ```
              import { AppContainer } from 'react-hot-loader'
              ```
              Then wrap our `<Route>` element in the `<AppContainer>` element in our render() method.  
              <br />
              Between where we define render() and where we call render(), add the following
              ```
              if (module.hot) {
                module.hot.accept('./main.js', () => {
                  render()
                })
              }
              ```
              This code is boiler plate code, and is nessesary for HMR (Hot Module Replacement).  
              Note: we pass in the path to main.js as the entry point for the HMR server to build its dependency graph.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Finally, add the following script to your *package.json*
              ```
              "serve": "webpack-dev-server"
              ```
              then simply run
              ```
              yarn serve
              ```
              and watch a new tab open in your default browser on port 8081 with our ~~shiny~~ navigation links  
              <br />
              <br />
              Oh fine, I'll admit it doesn't look all that appealing.  
              Resulting code below...  
              Styling ==>  
            </script>
          </section>
          <section data-markdown> <!-- main.js -->
            <script type="text/template">
              *main.js*
              ```
              import React from 'react'
              import ReactDOM from 'react-dom'
              import { AppContainer } from 'react-hot-loader'
              import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'

              import NavBar from './common/navbar.component.jsx'

              import './index.html'

              const appContainer = document.getElementById('app')

              const render = () => {
                ReactDOM.render(
                  <AppContainer>
                    <Router>
                      <div>
                        <NavBar />
                        <Switch>
                          <Route path={'/'} component={null} exact />
                          <Route path={'/github'} component={null} exact />
                        </Switch>
                      </div>
                    </Router>
                  </AppContainer>,
                  appContainer
                )
              }

              if (module.hot) {
                  module.hot.accept('./main.js', () => {
                      render()
                  })
              }

              render()
              ```
            </script>
          </section>
          <section data-markdown> <!-- webpack.config.js -->
            <script type="text/template">
              *webpack.config.js*
              ```
              var webpack = require('webpack')
              var path = require('path')

              var SRC = path.resolve(__dirname, 'src')
              var DIST = path.resolve(__dirname, 'dist')

              var config = {
                entry: [
                  './src/main.js'
                ],

                output: {
                  path: DIST,
                  filename: 'app.bundle.js'
                },

                devServer: {
                  inline: true, // Hot reloading
                  port: 8081, // Port which the Dev Server will listen on
                  contentBase: './src', // Where the entry to your app is
                  open: true // Open site in new browser tab upon command execution
                },

                module: {
                  loaders: [
                    {
                      test: /\.jsx?$/,
                      exclude: /node_modules/,
                      loader: 'babel-loader'
                    },
                    {
                      test: /\.html$/,
                      loader: 'file-loader?name=[name].[ext]'
                    }
                  ]
                },

                plugins: [
                  new webpack.NamedModulesPlugin()
                ]
              }

              module.exports = config
              ```
            </script>
          </section>
        </section>
        <section> <!-- Slide 11: styling -->
          <section data-markdown>
            <script type="text/template">
              # Basic styling
              Putting lipstick on our ~~pig~~ app
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Today, we break from convention! No global styleseets!!!  
              We're going *inline styles*  
              <img src='resources/deal-with-it.gif' />
              <br />
              In all seriousness, we will be following [FaceBook's approach](https://facebook.github.io/react/docs/dom-elements.html#style) 
              here.  
              Syling in React can be achieved in many ways. I suggest reading up the various opinions of inline styles vs css, as there doesn't seem to be
              an overwhelming consensus on what is right.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Going back to our *navbar.component.jsx* file, we're going to create a js object to represent our sytles.
              ```
              const navlinkBarStyle = {
                listStyleType: 'none',
                display: 'inline-block',
                padding: '5px'
              }
              ```
              And then add them to the `<li>` elements
              ```
              <li key='home' style={navlinkBarStyle}>
                <NavLink to={'/'} activeClassName='active'>Home</NavLink>
              </li>
              <li key='github' style={navlinkBarStyle}>
                <NavLink to={'/github'} activeClassName='active'>Github</NavLink>
              </li>
              ```
              Note. When defining styles, convert hyphen case to camelCase.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              That's all I'll cover here.  
              As I said, how you style your application comes down to your needs and preferences.  
              <br />
              Redux ==>
            </script>
          </section>
        </section>
        <section> <!-- Slide 12: redux store setup -->
          <section data-markdown>
            <script type="text/template">
              # Setting up the Redux store
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Let's install Redux and supporting pacakges.  
              In our terminal, run
              ```
              yarn add redux react-redux redux-thunk redux-logger
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We now need to setup our redux store.  
              Create a folder called *redux* in our *src* directory and create a filed called *configureStore.js*
              ```
              src/redux/configureStore.js
              ```
              In that file, add the following
              ```
              import { createStore, applyMiddleware, compose } from 'redux'
              import thunk from 'redux-thunk'
              import { logger } from 'redux-logger'
              import githubApi from '../github/github.api.middleware.js'
              import rootReducer from './rootReducer.js'

              const reactDevTools = window.devToolsExtension ? window.devToolsExtension() : f => f

              const configureStore = (preloadedState) => {
                const middlewares = [thunk, githubApi, logger]
                const middlewareEnhancer = applyMiddleware(...middlewares)
                const enhancers = compose(middlewareEnhancer, reactDevTools)

                return createStore(rootReducer, preloadedState, enhancers)
              }

              export default configureStore
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Line by line breakdown
              ```
              import { createStore, applyMiddleware, compose } from 'redux'
              ```
              *createStore* is for creating the redux store.  
              *applyMiddleware* applies [redux middleware](http://redux.js.org/docs/advanced/Middleware.html). 
              I'll touch more upon middleware in a few slides.  
              *compose* allows use to string together a series of enhancers for our store.  
              <br />
              ```
              import thunk from 'redux-thunk'
              ```
              thunk is a middleware which allows for easier management of async actions (such as web api calls).
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              import { logger } from 'redux-logger'
              ```
              This is the default instance of a logger middleware. It needs to be the last middleware initialised.  
              <br />
              ```
              import githubApi from '../github/github.api.middleware.js'
              import rootReducer from './rootReducer.js'
              ```
              These do not exist yet. We'll be creating them soon... very soon....  
              <br />
              ```
              const reactDevTools = window.devToolsExtension ? window.devToolsExtension() : f => f
              ```
              This is boilerplate code for initialising the devToolsExtension if you have them installed in your browser (recommended)
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              const configureStore = (preloadedState) => { ... }
              export default configureStore
              ```
              We are returning the store to whatever initialises it, and giving that entity the option to set a pre loaded state.  
              <br />
              ```
              const middlewares = [thunk, githubApi, logger]
              ```
              Here we are arranging the middlewares in order of execution. 
              Every middleware **SHOULD**â„¢ call the next() method, triggering the next middleware until there are no more middleware left, 
              then the intercepted action goes on to the reducers. You'll see this when we create our github api middleware.  
              We have NOT actually setup the middlewares yet.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              const middlewareEnhancer = applyMiddleware(...middlewares)
              ```
              Here we actually apply the middleware to the store.  
              Note we are using the spread operator when passing in the middleware array. This is equivalent to
              ```
              applyMiddleware(thunk, githubApi, logger) // Array has been spread upon function invokation
              ```
              Touching upon the ordering point again, the above results in effectively
              ```
              thunk(githubApi(logger(store.dispatch)))(action) // middlewares are being composed together
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ```
              const enhancers = compose(middlewareEnhancer, reactDevTools)
              ```
              We are [composing](https://en.wikipedia.org/wiki/Function_composition_(computer_science)) our middlewares with the initialiser function for React Dev Tools.  
              <br />
              Then finally, we assemble and return the redux store.
              ```
              return createStore(rootReducer, preloadedState, enhancers)
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              In our *main.js* file, we need to import our configureStore function and other redux related libraries
              ```
              import { Provider } from 'react-redux'
              import configureStore from './redux/configureStore'
              ```
              Anywhere before the definition of the render() function and after the imports, add the following code
              ```
              const initialState = {}
              const store = configureStore(initialState)
              ```
              Then wrap the `<Router>` element with the `<Privider>` element. We also need to pass the store into the provider.
              ```
              <AppContainer>
                <Provider store={store}>
                  <Router>
                    ...
                  </Router>
                </Provider>
              </AppContainer>
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Before we can build, we need to create our root reducer and github middleware.  
              ==>
            </script>
          </section>
        </section>
        <section> <!-- Slide 13: reducers, actions -->
          <section data-markdown>
            <script type="text/template">
              # Actions and Reducers
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Actions
              Through actions, we define the states in which our application can be in. For our example 
              of fetching GitHub repositories, we can...  
              * Start a fetch
              * Receive fetched repositories
                * Handle failure
                * Display if successful
              Which we'll represent with action types.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Create a directory in *src* called *github*. This is our first domain in our DDD approach.  
              Then create a file in the *github* directory called *github.actionTypes.js*
              ```
              src/github/github.actionTypes.js
              ```
              Within this file, lets define our 3 main states/actions
              ```
              export const FETCH_REPOSITORIES_START = 'FETCH_REPOSITORIES_START'
              export const FETCH_REPOSITORIES_FAILED = 'FETCH_REPOSITORIES_FAILED'
              export const FETCH_REPOSITORIES_SUCCESS = 'FETCH_REPOSITORIES_SUCCESS'
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Next let's setup our actions. Create:
              ```
              src/github/github.action.js
              ```
              then import our actionTypes into it.  
              We are going to be following the action creator pattern, where we export a function which returns an action.
              ````
              import * as types from './github.actionTypes'

              export const setRepositories = repositories => {
                return {
                  type: types.FETCH_REPOSITORIES_SUCCESS,
                  repositories
                }
              }
              export const fetchRepositoriesFailed = error => {
                return {
                  type: types.FETCH_REPOSITORIES_FAILED,
                  error
                }
              }
              export const loadReposForUser = username => {
                // validate username?
                return {
                  type: types.FETCH_REPOSITORIES_START,
                  username
                }
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Now that the actions are setup, let's move onto the reducer.  
              Create a new file:
              ```
              src/github/github.reducer.js
              ```
              Import our actionTypes and setup our reducer method with a switch on the received action.
              ```
              import * as types from './github.actionTypes'

              const github = (state = [], action) => {
                switch (action.type) {
                  case types.FETCH_REPOSITORIES_START:
                  case types.FETCH_REPOSITORIES_SUCCESS:
                  case types.FETCH_REPOSITORIES_FAILED:
                  default:
                    return state
                }
              }
              export default github
              ```
              We'll come back to this again in a bit.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Onto the root reducer!  
              If you remember back a few slides, we were importing a rootReducer into our configureStore file. It's now time to create that reducer!  
              <br />
              Create a new file:
              ```
              src/redux/rootReducer.js
              ```
              This file is fairly simple, but there are some caveats to keep in mind.  
              ```
              import { combineReducers } from 'redux'
              import Github from '../github/github.reducer'

              export default combineReducers({
                Github
              })
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              The role of the combineReducers() method is to allow us to define many reducers and not worry about dealing with the fact that the store only accepts 1.  
              Having said that, it's important to know how the reducer maps to the state object.  
              In the case of:
              ```
              combineReducers({ExampleReducer1, ExampleReducer2})
              ```
              Our store object will take on the shape of:
              ```
              {
                ExampleReducer1: { ... },
                ExampleReducer2: { ... }
              }
              ```
              Remebering back to our reducer, it takes in an action and a state. 
              The state object being passed in is the object in the store whose reducer maps to the key in the store object.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              A 2nd example:
              ```
              combineReducers({ExampleReducer1, reducer2: ExampleReducer2})
              ```
              Would result in a store looking like:
              ```
              {
                ExampleReducer1: { ... },
                reducer2: { ... }
              }
              ```
              This naming matters when fetching information from the store from within a component.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              We'll leave the reducers for the time being and move onto building our github component.
            </script>
          </section>
        </section>
			</div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
		<script>
			Reveal.initialize({
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>